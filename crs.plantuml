@startuml

frame "A" {


  package "crs_models" {
    abstract class ContinuousDynamicModel<StateType, InputType, StateDimension, InputDimension> {
      {abstract}  StateType applyModel(StateType state, InputType control_input)
      {abstract}  void getNumericalJacobian(StateType state, InputType input, Matrix& A, Matrix& B)
    }

    abstract class DiscreteDynamicModel<StateType, InputType, StateDimension, InputDimension> {
      {abstract}  StateType applyModel(StateType state, InputType control_input)
      {abstract}  void getNumericalJacobian(StateType state, InputType input, Matrix& A, Matrix& B)
    }

    abstract class DiscreteDynamicModelWrapper<StateType, InputType, StateDimension, InputDimension> {
      + ContinuousDynamicModel<> cont_model 
      {abstract} StateType applyModel(StateType state, InputType control_input)
      + void getNumericalJacobian(StateType state, InputType input, Matrix& A, Matrix& B)
    }


    DiscreteDynamicModel <-- DiscreteDynamicModelWrapper

    class ContinuousPacejkaModel<pacejka_car_state, pacejka_car_input, 6, 2> {
      + pacejka_car_state applyModel(pacejka_car_state state, pacejka_car_input control_input)
      + void getNumericalJacobian(pacejka_car_state state, pacejka_car_input input, Matrix& A, Matrix& B)
    }

    class DiscretePacejkaModel<pacejka_car_state, pacejka_car_input, 6, 2> {
      + PacejkaContinuous<pacejka_car_state, pacejka_car_input, 6, 2> cont_model 
      + pacejka_car_state applyModel(pacejka_car_state state, pacejka_car_input control_input)
      + void getNumericalJacobian(pacejka_car_state state, pacejka_car_input input, Matrix& A, Matrix& B)
    }

    ContinuousDynamicModel <-- ContinuousPacejkaModel
    DiscreteDynamicModelWrapper <-- DiscretePacejkaModel
    DiscretePacejkaModel o-- ContinuousPacejkaModel


    class ContinuousKinematicModel<kinematic_car_state, kinematic_car_input, 4, 2> {
      + kinematic_car_state applyModel(kinematic_car_state state, kinematic_car_input control_input)
      + void getNumericalJacobian(kinematic_car_state state, kinematic_car_input input, Matrix& A, Matrix& B)
    }

    class DiscreteKineamticModel<kinematic_car_state, kinematic_car_input, 4, 2> {
      + PacejkaContinuous<kinematic_car_state, kinematic_car_input, 4, 2> cont_model 
      + kinematic_car_state applyModel(kinematic_car_state state, kinematic_car_input control_input)
      + void getNumericalJacobian(kinematic_state state, kinematic_car_input input, Matrix& A, Matrix& B)
    }

    struct pacejka_car_state {
      +   double pos_x
      +   double pos_y
      +   double yaw
      +   double vel_x
      +   double vel_y
      +   double yaw_rate
    }

    struct pacejka_car_input {
      +   double torque
      +   double steer
    }

    struct kinematic_car_state {
      +   double pos_x
      +   double pos_y
      +   double yaw
      +   double velocity
    }

    struct kinematic_car_input {
      +   double torque
      +   double steer
    }

    struct kinematic_params {
      + double lr
      + double lf
      + double tau
      + double a
      + double b
    }

    struct pacejka_params {
      + double lr
      + double lf
      + double m
      + double I
      + double Df
      + double Cf
      + double Bf
      + double Dr
      + double Cr
      + double Br
      + double Cm1
      + double Cm2
      + double Cd
      + double Croll
    }


    ContinuousDynamicModel <-- ContinuousKinematicModel
    DiscreteDynamicModelWrapper <-- DiscreteKineamticModel
    DiscreteKineamticModel o-- ContinuousKinematicModel

    DiscreteKineamticModel o-- kinematic_car_input
    ContinuousKinematicModel o-- kinematic_car_input
    DiscreteKineamticModel o-- kinematic_car_state
    ContinuousKinematicModel o-- kinematic_car_state
    ContinuousKinematicModel o-- kinematic_params

    ContinuousPacejkaModel o-- pacejka_car_input
    DiscretePacejkaModel o-- pacejka_car_input
    DiscretePacejkaModel o-- pacejka_car_state
    ContinuousPacejkaModel o-- pacejka_car_state
    ContinuousPacejkaModel o-- pacejka_params
  }

  package "crs_sensor_models" {

    struct measurement {
      + string key
      + Vector measurement_data
      + double timstamp
    }

    abstract class SensorModel<StateType, InputType, StateDimension> {
      - Matrix R
      {abstract}  Vector applyModel(StateType state, InputType control_input)
      {abstract}  void getNumericalJacobian(StateType state, InputType input, Matrix& H)
      + Matrix getR()
      + {static} string getKey()
    }


    package "kinematic_sensor_models" {

      class ImuSensorModel<kinematic_car_state, kinematic_car_input, 4> {
        - Matrix<3,3> R
        + Vector applyModel(StateType state, kinematic_car_input control_input)
        + void getNumericalJacobian(StateType state, kinematic_car_input input, Matrix& H)
        + Matrix getR()
        + {static} string getKey()
      }

      class ViconSensorModel<kinematic_car_state, kinematic_car_input, 4> {
        - Matrix<3,3> R
        + Vector applyModel(kinematic_car_state state, kinematic_car_input control_input)
        + void getNumericalJacobian(kinematic_car_state state, kinematic_car_input input, Matrix& H)
        + Matrix getR()
        + {static} string getKey()
      }


      SensorModel <-- ViconSensorModel
      SensorModel <-- ImuSensorModel

      ImuSensorModel o-- kinematic_car_state
      ImuSensorModel o-- kinematic_car_input
      ViconSensorModel o-- kinematic_car_state
      ViconSensorModel o-- kinematic_car_input
    }


    package "pacejka_sensor_models" {

      class ImuSensorModel_<pacejka_car_state, pacejka_car_input, 6> {
        - Matrix<3,3> R
        + Vector applyModel(pacejka_car_state state, pacejka_car_input control_input)
        + void getNumericalJacobian(pacejka_car_state state, pacejka_car_input input, Matrix& H)
        + Matrix getR()
        + {static} string getKey()
      }

      class ViconSensorModel_<pacejka_car_state, pacejka_car_input, 6> {
        - Matrix<3,3> R
        + Vector applyModel(pacejka_car_state state, pacejka_car_input control_input)
        + void getNumericalJacobian(pacejka_car_state state, pacejka_car_input input, Matrix& H)
        + Matrix getR()
        + {static} string getKey()
      }

      SensorModel <-- ViconSensorModel_
      SensorModel <-- ImuSensorModel_

      ImuSensorModel_ o-- kinematic_car_state
      ImuSensorModel_ o-- kinematic_car_input
      ViconSensorModel_ o-- kinematic_car_state
      ViconSensorModel_ o-- kinematic_car_input
    }
  }


  package "crs_estimation" {

    abstract class BaseEstimator<StateType> {
      +  StateType getStateEstimate()
        {abstract} void measurementCallback(measurement data)
    }

    abstract class ModelBasedEstimator<StateType, InputType> {
      {abstract} void controlInputCallback (InputType input, double timestamp)
    }
    BaseEstimator <-- ModelBasedEstimator

    package "kalman" {
       class DiscreteEKF<StateType, InputType, StateDimension, InputDimension> {
       - StateType best_state
       - DiscreteDynamicModel<StateType, InputType, InputDimension> discrete_model 
       + Map<string, SensorModel> key_to_sensor_model

       + void controlInputCallback(InputType input, double timestamp)
       + void measurementCallback(measurement measurement)

       + void predict(InputType input, double timestep)
       + void measurementUpdate(measurement data)
       + StateType getStateEstimate()

      }
      DiscreteEKF o-- SensorModel
      DiscreteEKF o-- measurement
      DiscreteEKF o-- DiscreteDynamicModel
    }

    package "lowpass" {

      abstract class LowpassEstimator<StateType> {
        +  StateType getStateEstimate()
        {abstract} void measurementUpdate(measurement data)
      }

      struct car_lowpass_parameters {
        + vector<double> b_dx
        + vector<double> a_dx
        + vector<double> b_dy
        + vector<double> a_dy
        + vector<double> b_yaw
        + vector<double> a_yaw
        + vector<double> b_dyaw
        + vector<double> a_dyaw
      }

      class PacejkaLowpassEstimator<pacejka_car_state> {
       + pacejka_car_state best_state

       + void measurementUpdate(measurement data)
       + pacejka_car_state getStateEstimate()

      }
      LowpassEstimator <-- PacejkaLowpassEstimator
      PacejkaLowpassEstimator o- pacejka_car_state
      PacejkaLowpassEstimator o-- measurement
      PacejkaLowpassEstimator o-- car_lowpass_parameters
    }
    BaseEstimator <-- LowpassEstimator
    ModelBasedEstimator <-- DiscreteEKF

  }

  package "mpc_solvers" {

      abstract class MpcSolver<DynamicsType, CostType, OtherParams> {
        {abstract} + int getStateDimension() const
        {abstract} + int getInputDimension() const
        {abstract} + int getHorizonLength() const
        {abstract} + void setInitialStateConstraint(double constraint[])
        {abstract} + void setStateInitialGuess(int stage, double constraint[])
        {abstract} + void setInputInitialGuess(int stage, double constraint[])
        {abstract} + int solve(double x[], double u[])
        {abstract} + void updateParams(int stage, DynamicsType model_dynamics, const CostType costs, OtherParams others)
      }
      
    package "pacejka_solvers" {


      struct trajectory_track_point_ {
        + double x
        + double y
        + double grad_x
        + double grad_y
        + double theta
        + double phi
      }

    
      abstract class PacejkaMpccSolver {
        + int getStateDimension()
        + int getInputDimension() 
        {abstract} + int getHorizonLength()
        {abstract} + void setInitialStateConstraint(double constraint[])
        {abstract} + void setStateInitialGuess(int stage, double constraint[])
        {abstract} + void setInputInitialGuess(int stage, double constraint[])
        {abstract} + int solve(double x[], double u[])
        {abstract} + void updateParams(int stage, pacejka_params model_dynamics, tracking_costs costs, trajectory_track_point others)
      }

      class AcadosPacejkaMpccSolver {
        + int getStateDimension()
        + int getInputDimension() 
        + int getHorizonLength()
        + void setInitialStateConstraint(double constraint[])
        + void setStateInitialGuess(int stage, double constraint[])
        + void setInputInitialGuess(int stage, double constraint[])
        + int solve(double x[], double u[])
        + void updateParams(int stage, pacejka_params model_dynamics, tracking_costs costs, trajectory_track_point referenec)
      }


      struct trajectory_track_point_ {
        + double x
        + double y
        + double grad_x
        + double grad_y
        + double theta
        + double phi
      }


      struct tracking_costs {
        + double Q1
        + double Q2
        + double R1
        + double R2
        + double R3
        + double q
      }

      MpcSolver <-- PacejkaMpccSolver
      PacejkaMpccSolver o-- tracking_costs
      PacejkaMpccSolver o-- trajectory_track_point_
      PacejkaMpccSolver <-- AcadosPacejkaMpccSolver
      PacejkaMpccSolver <- pacejka_params
    }


    package "pacejka_safety_solvers" {


      struct reference_input {
        + double torque
        + double steer
        + double cost_torque
        + double cost_steer
        + double cost_delta_torque
        + double cost_delta_steer
      }

      struct reference_on_track {
        + double xp_track
        + double yp_track
        + double yaw_track
        + double xp_e
        + double yp_e
        + double yaw_e
      }

      abstract class PacejkaSafetySolver {
        + int getStateDimension()
        + int getInputDimension()
        {abstract} + int getHorizonLength()
        {abstract} + void setInitialStateConstraint(double constraint[])
        {abstract} + void setStateInitialGuess(int stage, double constraint[])
        {abstract} + void setInputInitialGuess(int stage, double constraint[])
        {abstract} + int solve(double x[], double u[])
        {abstract} + void updateParams(int stage, pacejka_params model_dynamics, reference_input ref_input, reference_on_track reference)
      }

      class AcadosPacejkaSafetySolver {
        + int getStateDimension()
        + int getInputDimension()
         + int getHorizonLength()
         + void setInitialStateConstraint(double constraint[])
         + void setStateInitialGuess(int stage, double constraint[])
         + void setInputInitialGuess(int stage, double constraint[])
         + int solve(double x[], double u[])
       + void updateParams(int stage, pacejka_params model_dynamics, reference_input ref_input, reference_on_track reference)
     }


      MpcSolver <-- PacejkaSafetySolver
      PacejkaSafetySolver o-- reference_on_track
      PacejkaSafetySolver o-- reference_input
      PacejkaSafetySolver <-- AcadosPacejkaSafetySolver
      PacejkaSafetySolver <- pacejka_params

}

    package "pacejka_tracking_solvers" {


      class AcadosPacejkaTrackingMpcSolver {
        + int getStateDimension()
        + int getInputDimension()
         + int getHorizonLength()
         + void setInitialStateConstraint(double constraint[])
         + void setStateInitialGuess(int stage, double constraint[])
         + void setInputInitialGuess(int stage, double constraint[])
         + int solve(double x[], double u[])
         + void updateParams(int stage, pacejka_params model_dynamics, tracking_cost costs, trajectory_track_point others)
      }
      
      struct tracking_cost {
        + double Q1
        + double Q2
        + double R1
        + double R2
      }


      abstract class PacejkaTrackingMpcSolver {
        + int getStateDimension()
        + int getInputDimension()
        {abstract} + int getHorizonLength()
        {abstract} + void setInitialStateConstraint(double constraint[])
        {abstract} + void setStateInitialGuess(int stage, double constraint[])
        {abstract} + void setInputInitialGuess(int stage, double constraint[])
        {abstract} + int solve(double x[], double u[])
        {abstract} + void updateParams(int stage, pacejka_params model_dynamics, tracking_cost costs, trajectory_track_point others)
      }


      
      struct trajectory_track_point {
        + double x
        + double y
        + double grad_x
        + double grad_y
        + double theta
        + double phi
      }
      
      MpcSolver <-- PacejkaTrackingMpcSolver
      PacejkaTrackingMpcSolver o-- tracking_cost
      PacejkaTrackingMpcSolver o-- trajectory_track_point
      PacejkaTrackingMpcSolver <-- AcadosPacejkaTrackingMpcSolver
      PacejkaTrackingMpcSolver <- pacejka_params
      
}

  }
    
  package "crs_controls" {
    abstract class BaseController<StateType, InputType> {
      - Trajectory trajectory
      {abstract} InputType getControlInput(StateType state, double timestamp)
      {abstract} bool isInitializing()
    }

    abstract class ModelBasedController<ModelType, StateType, InputType> {
      - Trajectory trajectory
      - ModelType model_
      {abstract} InputType getControlInput(StateType state, double timestamp)
      {abstract} bool isInitializing()
    }
    abstract class MpcController<ModelType, StateType, InputType> {
      - Trajectory trajectory
      - ModelType model_
      {abstract} InputType getControlInput(StateType state, double timestamp)
      {abstract} bool isInitializing()
      {abstract} vector<vector<double>> getPlannedTrajectory()
    }

    BaseController <-- ModelBasedController
    ModelBasedController <-- MpcController

    struct FfFbConfig {
      + bool use_filter
      + vector<double> b_filter
      + vector<double> a_filter
      + double target_velocity
      + double lag_compensation_time
      + double a_torque
      +  double b_torque
      + double Kd
      + double Kp
      + double Ki
      + double steer_limit
      + double K_torque_curv
      + int mean_curv_dist
      + double look_ahead_dist
    }
    
    struct pid_const_ref_config {
      + double lag_compensation_time
      + bool use_filter
      + vector<double> b_filter
      + vector<double> a_filter
      + double a_torque
      + double b_torque
      + double Kd
      + double Kp
      + double Ki
      + double Kd_angle
      + double Kp_angle
      + double Ki_angle
      + double steer_limit
    }

    struct pid_config {
      + double target_velocity
      + double look_ahead_time
      + bool use_filter
      + vector<double> b_filter
      + vector<double> a_filter
      + double a_torque
      + double b_torque
      + double Kd
      + double Kp
      + double Ki
    }

    class PacejkaPIDController {
      - Trajectory trajectory
      - pid_config config
      + pacejka_car_input getControlInput(pacejka_car_state state)
      + bool isInitializing()
    }


    class PacejkaConstRefPIDController {
      - Trajectory trajectory
      - pid_const_ref_config config
      + void setConfig(pid_const_ref_config config)
      + pacejka_car_input getControlInput(pacejka_car_state state)
      + bool isInitializing()
    }
    
    class FfFbController {
      - Trajectory trajectory
      - FfFbConfig config
      - ModelType model_
      + pacejka_params model_params_ 
      + pacejka_car_input getControlInput(pacejka_car_state state, double timestamp)
      + bool isInitializing()
      + void setConfig(FfFbConfig config)
    }  
    
    struct mpcc_pacejka_config {
      + double Q1
      + double Q2
      + double R1
      + double R2 
      + double R3
      + double q
      + double lag_compensation_time

    }

    class PacejkaMpccController {
      - Trajectory trajectory
      - ModelType model_
      - mpcc_pacejka_config config
      - PacejkaMpccSolver solver
      + pacejka_car_input getControlInput(pacejka_car_state state, double timestamp)
      + bool isInitializing()
      + void initialize(pacejka_car_state state)
      + void setConfig(MpccPacejkaConfig config)
      + vector<vector<double>> getPlannedTrajectory()
    }


    class PacejkaTrackingMpcController {
      - Trajectory trajectory
      - ModelType model_
      - mpcc_pacejka_config config
      - PacejkaTrackingMpcSolver solver
      + pacejka_car_input getControlInput(pacejka_car_state state, double timestamp)
      + bool isInitializing()
      + void initialize(pacejka_car_state state)
      + void setConfig(tracking_mpc_pacejka_config config)
      + vector<vector<double>> getPlannedTrajectory()
    }

    struct tracking_mpc_pacejka_config {
        double Q1
        double Q2
        double R1
        double R2
        double lag_compensation_time
        string solver_type
    }
    
    
    
    ModelBasedController <-- FfFbController
    BaseController <-- PacejkaPIDController
    MpcController <-- PacejkaTrackingMpcController
    MpcController <-- PacejkaMpccController

    FfFbController o- pacejka_car_input
    FfFbController o- pacejka_car_state
    FfFbController o- pacejka_params
    FfFbController o-- FfFbConfig

    PacejkaPIDController o- pacejka_car_input
    PacejkaPIDController o- pacejka_car_state
    PacejkaPIDController o-- pid_config
    
    BaseController <-- PacejkaConstRefPIDController
    PacejkaConstRefPIDController o- pacejka_car_input
    PacejkaConstRefPIDController o- pacejka_car_state
    PacejkaConstRefPIDController o-- pid_const_ref_config

    PacejkaMpccController o- pacejka_car_input
    PacejkaMpccController o- pacejka_car_state
    PacejkaMpccController o- pacejka_params
    PacejkaMpccController o-- mpcc_pacejka_config

    PacejkaMpccController o-- PacejkaMpccSolver


    PacejkaTrackingMpcController o- pacejka_car_input
    PacejkaTrackingMpcController o- pacejka_car_state
    PacejkaTrackingMpcController o- pacejka_params
    PacejkaTrackingMpcController o-- PacejkaTrackingMpcSolver

    PacejkaTrackingMpcController o-- tracking_mpc_pacejka_config


  }


  package "commons" {
      abstract class Trajectory {
        + int getClosestTrackPointIdx(Vector2D point, float precision)
        + Vector2D getClosestTrackPoint(Vector2D point, float precision)
      }
      
      class StaticTrackTrajectory {
        + int getClosestTrackPointIdx(Vector2D point, float precision)
        + Vector2D getClosestTrackPoint(Vector2D point, float precision)
      }
      
      class DynamicPointTrajectory {
        + int getClosestTrackPointIdx(Vector2D point, float precision)
        + Vector2D getClosestTrackPoint(Vector2D point, float precision)
      }


    Trajectory <-- StaticTrackTrajectory
    Trajectory <-- DynamicPointTrajectory


    BaseController o-- Trajectory
  }

  package "crs_planning" {
    abstract class BasePlanner<TrajectoryType, StateType> {
      {abstract} vector<TrajectoryType> getPlannedTrajectory(StateType state, double timestamp)
      {abstract} bool goalReached(StateType state, vector<TrajectoryType> trajectory)
    }

    struct cartesian_reference_point {
        double x
        double y
    } 
    
    struct multi_car_cartesian_reference_point {
        vector<string> namespaces;
        vector<cartesian_reference_point> points;
    } 
    class MultiPacejkaLloydPlanner {
        + vector<multi_car_cartesian_reference_point> getPlannedTrajectory(map<string, pacejka_car_state> state, double timestamp)
        + bool goalReached(map<string, pacejka_car_state> states, vector<multi_car_cartesian_reference_point> trajectory)
    }

    BasePlanner <-- MultiPacejkaLloydPlanner

    MultiPacejkaLloydPlanner o-- multi_car_cartesian_reference_point
    MultiPacejkaLloydPlanner o-- cartesian_reference_point

    multi_car_cartesian_reference_point o-- cartesian_reference_point
  }
  package "crs_safety" {

    abstract class SafetyFilter<StateType, InputType> {
      - Trajectory trajectory
      {abstract} InputType getSafeControlInput(const StateType state, const InputType control_input)
    }

    abstract class ModelBasedSafetyFilter<StateType, InputType, ModelType> {
      - Trajectory trajectory
      - ModelType model
      {abstract} InputType getSafeControlInput(const StateType state, const InputType control_input)
      }
    
    abstract class MpcBasedSafetyFilter<StateType, InputType, ModelType, SolverType> {
      - Trajectory trajectory
      - ModelType model
      - SolverType solver
      {abstract} InputType getSafeControlInput(const StateType state, const InputType control_input)
    }

    class PacejkaMpcSafetyFilter {
      - Trajectory trajectory
      - ModelType model
      - SolverType solver
      - pacejka_mpc_safety_config config_
      - vector<pair<int, pacejka_car_state>> calculateReferenceTrajectory(pacejka_car_state state, pacejka_car_input input)
      + pacejka_car_input getSafeControlInput(const pacejka_car_state state, const pacejka_car_input control_input)
    }

    class SimplePacejkaCollisionAvoider<pacejka_car_state, pacejka_car_input,DiscretePacejkaModel> {
      - Trajectory trajectory
        pacejka_car_input getSafeControlInput(const pacejka_car_state state, const pacejka_car_input control_input);
    }

    SafetyFilter <-- ModelBasedSafetyFilter
    ModelBasedSafetyFilter <-- MpcBasedSafetyFilter
    ModelBasedSafetyFilter <-- SimplePacejkaCollisionAvoider

    SafetyFilter o-- Trajectory
    MpcBasedSafetyFilter o-- PacejkaMpcSafetyFilter
    PacejkaMpcSafetyFilter o-- PacejkaSafetySolver
    MpcBasedSafetyFilter o-- MpcSolver
  }

}
@enduml
